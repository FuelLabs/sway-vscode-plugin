import{d as E,w as O,u as _,A as m,C as u,N as g,a as f,b as L,c as M,V as R,e as j}from"./config-039f390a.js";import{a as b,b as D,T as W,e as x,c as H,f as B,M as c,g as y,d as U,B as v,C as A,A as $,h as K,i as h,V as I,j as F,k as V}from"./config-27341492.js";import{d as z}from"./promise-632341a0.js";import{B as G,c as J}from"./BaseConnection-538d8d30.js";async function X(){let n=0,t=0;try{const{top:e=0,left:s=0,width:o=0}=await chrome.windows.getLastFocused();t=e,n=s+(o-b)}catch{const{screenX:s,screenY:o,outerWidth:i}=window;t=Math.max(o,0),n=Math.max(s+(i-b),0)}return{left:n,top:t}}async function Y(n){n&&chrome.tabs.remove(n).catch(()=>{})}async function Q(n){if(!n?.windowId||!n?.tabId)return!1;try{if(await chrome.windows.get(n.windowId))return await chrome.tabs.update(n.tabId,{selected:!0}),await chrome.windows.update(n.windowId,{focused:!0}),!0}catch{}return!1}async function Z(n){const{left:t,top:e}=await X();return(await chrome.windows.create({type:"popup",url:n,width:b,height:D+W,left:t,top:e}))?.id}function tt(n){return n?.tab}const et="salt";async function st(){const n=crypto.randomUUID();return await chrome.storage.local.set({salt:n}),n}async function nt(){return(await chrome.storage.local.get(et)).salt}async function C(){chrome.storage.local.remove("salt"),chrome.storage.session.clear()}async function T(){const{timer:n}=await chrome.storage.session.get("timer");return n||0}async function ot(){const{lockTime:n}=await chrome.storage.session.get("lockTime");chrome.storage.session.set({timer:E().add(n,"minute").valueOf()})}async function it(n,t){const e=await st();try{const s=await x(e,n);chrome.storage.session.set({data:s,lockTime:t,timer:E().add(t,"minute").valueOf()})}catch{C()}}async function rt(){const n=await nt(),{data:t,timer:e}=await chrome.storage.session.get(["data","timer"]);if(n&&e>Date.now())try{return await H(n,t)}catch{}return C(),null}const ct="/assets/content-script-loader.contentScript-875e4907.js";async function q(){chrome.tabs.query({url:"<all_urls>"},n=>{n.forEach(t=>{t.id&&chrome.scripting.executeScript({target:{tabId:t.id,allFrames:!0},files:[ct],injectImmediately:!0}).catch(()=>{})})})}q();chrome.runtime.onInstalled.addListener(n=>{n.reason===chrome.runtime.OnInstalledReason.INSTALL&&chrome.tabs.create({url:O()}),q()});chrome.alarms.create("KeepAwake",{periodInMinutes:1});chrome.alarms.onAlarm.addListener(n=>{n.name==="KeepAwake"&&console.debug("[FUEL WALLET] KeepAwake signal")});const N=new Map,l=class{constructor(t){this.session=null,this.tabId=null,this.windowId=null,this.tab=null,this.rejectAllRequests=e=>{e===this.eventId&&(Y(this.tabId),this.client.rejectAllPendingRequests("Request cancelled without user response!"))},this.sendRequest=async e=>{if(this.eventId)this.communicationProtocol.postMessage({type:c.request,target:y,id:this.eventId,request:e});else throw new Error("UI not connected!")},this.onResponse=e=>{e.id===this.eventId&&e.response&&this.client.receive(e.response)},this.onUIEvent=e=>{if(this.session===e.session&&e.ready){const s=tt(e.sender);this.tab=s,this.tabId=s.id,this.eventId=e.id,this.openingPromise.resolve(this)}},this.communicationProtocol=t,this.openingPromise=z(),this.client=new U.JSONRPCClient(this.sendRequest),this.setupUIListeners(),this.setTimeout()}setTimeout(t=5e3){setTimeout(()=>{this.openingPromise.reject(new Error("PopUp not opened!"))},t)}setupUIListeners(){this.communicationProtocol.once(c.uiEvent,this.onUIEvent),this.communicationProtocol.on(c.response,this.onResponse),this.communicationProtocol.on(c.removeConnection,this.rejectAllRequests)}static async getCurrent(t){const e=N.get(t);return e&&await Q({tabId:e.tabId,windowId:e.windowId})?e:null}async requestConnection(t){return this.client.request("requestConnection",t)}async signMessage(t){return this.client.request("signMessage",t)}async sendTransaction(t){return this.client.request("sendTransaction",t)}async addAssets(t){return this.client.request("addAssets",t)}async addNetwork(t){return this.client.request("addNetwork",t)}};l.create=async(n,t,e)=>{const s=_(4),o=new l(e);N.set(n,o);const i=await Z(`${B.popup}?s=${s}#${t}`);return o.session=s,o.windowId=i,o};l.open=async(n,t,e)=>{let s=await l.getCurrent(n);return s||(s=await l.create(n,t,e)),s.openingPromise.promise};let p=l;class k{constructor(t){this.communicationProtocol=t,this.server=new U.JSONRPCServer,this.server.applyMiddleware(this.connectionMiddleware.bind(this)),this.setupListeners(),this.externalMethods([this.ping,this.version,this.isConnected,this.accounts,this.connect,this.network,this.disconnect,this.signMessage,this.sendTransaction,this.currentAccount,this.addAssets,this.assets,this.addNetwork,this.addAbi,this.getAbi])}static start(t){return new k(t)}setupListeners(){this.communicationProtocol.on(c.request,async t=>{if(t.target!==v)return;const e=t.sender.origin,s=t.sender.tab.title,o=t.sender.tab.favIconUrl,i=await this.server.receive(t.request,{origin:e,title:s,favIconUrl:o});i&&this.communicationProtocol.postMessage({id:t.id,type:c.response,target:A,response:i})})}externalMethods(t){t.forEach(e=>{let s=e;e.name&&(s=e.name),this.server.addMethod(s,this[s].bind(this))})}async requireAccounts(){if((await m.getAccounts()).length===0)throw new Error("Unable to establish a connection. No accounts found")}async requireAccountConnection(t,e){if(!t)throw new Error("connection not found");if(!t.accounts.includes($.fromString(e||"0x00").toString()))throw new Error("address is not authorized for this connection.")}async requireConnection(t){if(!((t?.accounts||[]).length>0))throw new Error("Connection not established. Please call connect() first to request a connection")}async connectionMiddleware(t,e,s){if(["version","ping"].includes(e.method))return t(e,s);const i=await u.getConnection(s.origin);return["connect","isConnected"].includes(e.method)?await this.requireAccounts():await this.requireConnection(i),t(e,{connection:i,...s})}async sendEvent(t,e,s){this.communicationProtocol.broadcast(t,{target:A,type:c.event,events:[{event:e,params:s}]})}async version(){return K}async ping(){return!0}async isConnected(t,e){return!!e.connection}async connect(t,e){const s=e.origin,o=e.title,i=e.favIconUrl;let r=await u.getConnection(s);const a=(await m.getAccounts())?.filter(w=>!w.isHidden);return(!r||(r?.accounts.length||0)!==a.length)&&(r=await(await p.open(s,h.requestConnection(),this.communicationProtocol)).requestConnection({origin:s,title:o,favIconUrl:i,totalAccounts:a?.length||0})),r&&this.sendEvent(s,"connection",[!!r]),!!r}async disconnect(t,e){const s=e.origin;return s?(await u.removeConnection({origin:s}),this.sendEvent(s,"connection",[!1]),!0):!1}async accounts(t,e){const s=e.origin;return s?(await u.getConnection(s))?.accounts||[]:[]}async signMessage(t,e){const s=e.origin,o=e.title,i=e.favIconUrl;return await this.requireAccountConnection(e.connection,t.address),await(await p.open(s,h.requestMessage(),this.communicationProtocol)).signMessage({...t,origin:s,title:o,favIconUrl:i})}async sendTransaction(t,e){await this.requireAccountConnection(e.connection,t.address);const s=e.origin,o=e.title,i=e.favIconUrl;if((await g.getSelectedNetwork())?.url!==t.provider.url)throw new Error([`${t.provider.url} is different from the user current network!`,"Request the user to add the new network. fuel.addNetwork([...])."].join(`
`));return await(await p.open(s,h.requestTransaction(),this.communicationProtocol)).sendTransaction({...t,origin:s,title:o,favIconUrl:i})}async currentAccount(t,e){const s=await m.getCurrentAccount();return await this.requireAccountConnection(e.connection,s?.address),s?.address}async network(){return{url:(await g.getSelectedNetwork())?.url}}async assets(t){return await f.getAssets()||[]}async addAssets(t,e){const{assetsToAdd:s}=await f.validateAddAssets(t.assets),o=e.origin,i=e.title,r=e.favIconUrl;return await(await p.open(o,h.requestAddAssets(),this.communicationProtocol)).addAssets({assets:s,origin:o,title:i,favIconUrl:r}),!0}async addAbi(t){return await L.addAbi({data:t.abiMap}),!0}async getAbi(t){return await L.getAbi({data:t.contractId})}async addNetwork(t,e){const{network:s}=t;await g.assertAddNetwork({data:s});const o=e.origin,i=e.title,r=e.favIconUrl;return await(await p.open(o,h.requestAddNetwork(),this.communicationProtocol)).addNetwork({network:s,origin:o,title:i,favIconUrl:r}),!0}}class at extends G{constructor(){super(),this.removePort=t=>{const e=this.ports.get(t);e&&(e.onMessage.removeListener(this.onMessage),this.ports.delete(t),this.emit(c.removeConnection,t))},this.postMessage=t=>{const e=this.ports.get(t.id);e&&e.postMessage(t)},this.broadcast=(t,e)=>{const s=Array.isArray(t)?t:[t];this.ports.forEach(o=>{s.includes(o.sender?.origin||"")&&o.postMessage(e)})},this.getPortId=t=>{for(const[e,s]of this.ports.entries())if(s===t)return e;return null},this.onMessage=(t,e)=>{if(e.sender?.id!==chrome.runtime.id||![I,v].includes(t.target)||!Object.keys(c).includes(t.type))return;const o=this.getPortId(e);this.emit(t.type,Object.freeze({...t,id:o,sender:e.sender}))},this.ports=new Map}addConnection(t){const e=J();this.ports.set(e,t),this.setupListeners(e)}setupListeners(t){const e=this.ports.get(t);e&&!e.onMessage.hasListener(this.onMessage)&&(e.onMessage.addListener(this.onMessage),e.onDisconnect.addListener(()=>this.removePort(t)))}on(t,e){return super.on(t,e)}destroy(){this.ports.forEach(t=>t.disconnect()),this.ports.clear()}}class ut extends F{constructor(){super(),this.setupListeners()}setupListeners(){M.on("changes",t=>{t.forEach(e=>{switch(e.type){case 1:super.emit(`${e.table}:create`,e);break;case 2:super.emit(`${e.table}:update`,e);break;case 3:super.emit(`${e.table}:delete`,e);break}})}),M.open()}on(t,e){return super.on(t,e)}}class S{constructor(t){this.communicationProtocol=t,this.databaseObservable=new ut,this.setupApplicationWatcher()}static start(t){return new S(t)}createEvents(t){return{target:A,type:c.event,events:t}}setupApplicationWatcher(){this.databaseObservable.on("networks:update",async t=>{if(!t.obj.isSelected)return;const s=(await u.getConnections()).map(o=>o.origin);this.communicationProtocol.broadcast(s,this.createEvents([{event:"network",params:[{id:t.obj.id,url:t.obj.url}]}]))}),this.databaseObservable.on("accounts:update",async t=>{if(!t.obj.isCurrent)return;const e=t.obj,s=await u.getConnections(),o=a=>a.map(w=>w.origin),i=o(s.filter(a=>a.accounts.includes(e.address))),r=o(s.filter(a=>!i.includes(a.origin))),d=r.length!==i.length;this.communicationProtocol.broadcast(i,this.createEvents([{event:"currentAccount",params:[t.obj.address]}])),d&&this.communicationProtocol.broadcast(r,this.createEvents([{event:"currentAccount",params:[null]}]))}),this.databaseObservable.on("assets:update",t=>t.obj.isCustom&&this.broadcastAssets()),this.databaseObservable.on("assets:delete",()=>this.broadcastAssets()),this.databaseObservable.on("assets:create",()=>this.broadcastAssets()),this.databaseObservable.on("connections:delete",async t=>{const e=t.oldObj;this.communicationProtocol.broadcast(e.origin,this.createEvents([{event:"connection",params:[!1]}]))})}async broadcastAssets(){const e=(await u.getConnections()).map(o=>o.origin),s=await f.getAssets();this.communicationProtocol.broadcast(e,this.createEvents([{event:"assets",params:[s]}]))}}class P extends R{constructor(t){super(),this.communicationProtocol=t,this.autoLock(),this.autoUnlock(),this.setupListeners()}async unlock({password:t}){await super.unlock({password:t}),it(t,V)}async lock(){await super.lock(),this.emitLockEvent()}async isLocked(){const t=await super.isLocked();return t||await T()&&ot(),t}async autoLock(){setInterval(async()=>{const t=await T();t!==0&&t<Date.now()&&(C(),this.lock())},1e3)}async autoUnlock(){const t=await rt();t&&await super.unlock({password:t})}static start(t){return new P(t)}setupListeners(){this.communicationProtocol.on(c.request,async t=>{if(!t.sender?.origin?.includes(chrome.runtime.id)||t.sender?.id!==chrome.runtime.id||t.target!==I)return;const e=await this.server.receive(t.request);e&&this.communicationProtocol.postMessage({id:t.id,type:c.response,target:y,response:e})})}emitLockEvent(){const t=Array.from(this.communicationProtocol.ports.values()).filter(e=>e.sender?.id===chrome.runtime.id).map(e=>e.sender?.origin);this.communicationProtocol.broadcast(t,{type:c.event,target:y,events:[{event:"lock",params:[]}]})}}j(()=>{const n=new at;k.start(n),P.start(n),S.start(n),chrome.runtime.onConnect.addListener(t=>{if(t.sender?.id!==chrome.runtime.id){t.disconnect();return}[v,I].includes(t.name)&&n.addConnection(t)})});
//# sourceMappingURL=index.ts-6915d9f5.js.map
